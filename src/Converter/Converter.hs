{-# LANGUAGE TypeSynonymInstances #-}
module Converter (jpgToC) where

import qualified Data.ByteString as BS (readFile)
import Data.ByteString.Lazy            (toStrict)
import System.FilePath.Posix           (takeBaseName, (</>))
import Data.Time                       (getCurrentTime, UTCTime())

import Codec.Picture.Types
import Codec.Picture.Saving (imageToBitmap)
import Codec.Picture.Jpg    (decodeJpeg)
import Codec.Picture.Bitmap (decodeBitmap)

import RGB565               (toRGB565Hex, to4Hex)

jpgToC :: FilePath -> FilePath -> IO ()
jpgToC saveTo fp = do
  bs  <- BS.readFile fp
  case decodeJpeg bs of
    Left err     -> putStrLn $ "Error happend while decoding the jpg: " ++ err
    Right dynimg ->
      case decodeBitmap (toStrict (imageToBitmap dynimg)) of
        Left err'     -> putStrLn $ "Error happend while decoding the bmp " ++ err'
        Right dynimg' -> do
          time <- getCurrentTime
          let img@(Image w h _)  = fromDynamicImage dynimg'
              name               = takeBaseName fp
              content            = toCFile (encodePixels img) name (w, h) time
          writeFile (saveTo </> name ++ ".c") content
          putStrLn $ "Converted " ++ name ++ ".c"


encodePixels :: Image PixelRGBA8 -> [String]
encodePixels img@(Image w h _) = [ format (pixelAt img y x) | x <- [0..(h-1)], y <- [0..(w-1)]]
  where format (PixelRGBA8 r g b _) = toRGB565Hex (r, g, b)


toCFile :: [String] -> String -> (Int, Int) -> UTCTime -> String
toCFile content name (w, h) time = let clength  = show (length content)
                                       memusage = show (length content * 2) in
  "// Generated by   : JuicyConverter v0.1\n"                          ++
  "// Generated from : " ++ name      ++ ".jpg\n"                      ++
  "// Time generated : " ++ show time ++ "\n"                          ++
  "// Image Size     : " ++ show w ++ 'x' : show h ++ " pixels\n"      ++
  "// Memory usage   : " ++ memusage  ++ " bytes\n"                    ++
  "\n\n"                                                               ++
  "#if defined(__AVR__)\n"                                             ++
  "    #include <avr/pgmspace.h>\n"                                    ++
  "#elif defined(__PIC32MX__)\n"                                       ++
  "    #define PROGMEM\n"                                              ++
  "#elif defined(__arm__)\n"                                           ++
  "    #define PROGMEM\n"                                              ++
  "#endif\n"                                                           ++
  "\n"                                                                 ++
  "const unsigned short " ++ name ++ '[' : clength ++ "] PROGMEM={\n"  ++
  toCArray content 1

toCArray :: [String] -> Int -> String
toCArray []     _ = "};"
toCArray (x:xs) n = printHex x ++ com ++ toCArray xs (n+1)
  where com | n `mod` 16 == 0 = printCom n
            | otherwise       = ""

printHex :: String -> String
printHex hx = '0':'x': hx ++ ", "

printCom :: Int -> String
printCom n = ' ':' ':'/':'/':' ':'0':'x': to4Hex n ++ ' ':'(': show n ++ ") pixels\n"

---- Copied from
---- See http://hackage.haskell.org/package/JuicyPixels-util-0.2/docs/Codec-Picture-RGBA8.html

class ToPixelRGBA8 a where
    toRGBA8 :: a -> PixelRGBA8

instance ToPixelRGBA8 Pixel8 where
    toRGBA8 b = PixelRGBA8 b b b 255

instance ToPixelRGBA8 PixelYA8 where
    toRGBA8 (PixelYA8 l a) = PixelRGBA8 l l l a

instance ToPixelRGBA8 PixelRGB8 where
    toRGBA8 (PixelRGB8 r g b) = PixelRGBA8 r g b 255

instance ToPixelRGBA8 PixelRGBA8 where
    toRGBA8 = id

fromDynamicImage :: DynamicImage -> Image PixelRGBA8
fromDynamicImage (ImageY8 img)    = pixelMap toRGBA8 img
fromDynamicImage (ImageYA8 img)   = pixelMap toRGBA8 img
fromDynamicImage (ImageRGB8 img)  = pixelMap toRGBA8 img
fromDynamicImage (ImageRGBA8 img) = img

---- end of Codec.Picture.RGBA8